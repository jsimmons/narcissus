#version 460

#extension GL_GOOGLE_include_directive : require

#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_control_flow_attributes : require

#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_vote : require

#include "draw_2d.h"

struct Draw2dScatterConstants {
    uvec2 screen_resolution;
    uvec2 tile_resolution;

    uint draw_buffer_len;
    uint coarse_buffer_len;

    Draw2dCommandRef draw_buffer;
    GlyphRef glyph_buffer;
    CoarseRef coarse_buffer;
};

layout(std430, push_constant) uniform Draw2dScatterConstantsBlock {
    Draw2dScatterConstants constants;
};

const uint MAX_TILES = 256;
const uint BITMAP_STRIDE = MAX_TILES / 32;
const uint BITMAP_SIZE = MAX_TILES * BITMAP_STRIDE;

shared uint intersected_tiles[BITMAP_SIZE];

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

void main() {
    const uint local_id = gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID;
    const uint draw_index = gl_WorkGroupID.x * gl_WorkGroupSize.x + local_id;

    const bool in_bounds = draw_index < constants.draw_buffer_len;

    vec2 cmd_min = vec2(99999.9);
    vec2 cmd_max = vec2(-99999.9);
    if (in_bounds) {
        const Draw2dCmd cmd = constants.draw_buffer.values[draw_index];
        const uint cmd_type = cmd.packed_type >> 24;
        for (;;) {
            const uint scalar_type = subgroupBroadcastFirst(cmd_type);
            [[branch]]
            if (scalar_type == cmd_type) {
                switch (scalar_type) {
                    case DRAW_2D_CMD_RECT:
                        const Draw2dCmdRect cmd_rect = decode_rect(cmd);
                        cmd_min = cmd_rect.position - cmd_rect.half_extent - cmd_rect.border_width;
                        cmd_max = cmd_rect.position + cmd_rect.half_extent + cmd_rect.border_width;
                        break;
                    case DRAW_2D_CMD_GLYPH:
                        const Draw2dCmdGlyph cmd_glyph = decode_glyph(cmd);
                        const Glyph glyph = constants.glyph_buffer.values[cmd_glyph.index];
                        cmd_min = cmd_glyph.position + glyph.offset_min;
                        cmd_max = cmd_glyph.position + glyph.offset_max;
                        break;
                }
                break;
            }
        }
    }

    const uvec2 cmd_min_tile = uvec2(floor(max(min(cmd_min, constants.screen_resolution), 0.0) / TILE_SIZE));
    const uvec2 cmd_max_tile = uvec2(floor(max(min(cmd_max, constants.screen_resolution), 0.0) / TILE_SIZE));
    const uvec2 cmds_min_tile = subgroupMin(cmd_min_tile);
    const uvec2 cmds_max_tile = subgroupMax(cmd_max_tile);

    // Is any single command responsible for the entire bounds?
    const bool cmd_absolute_min = cmd_min_tile == cmds_min_tile;
    const bool cmd_absolute_max = cmd_max_tile == cmds_max_tile;
    const bool use_combined_bounds = subgroupAny(cmd_absolute_min && cmd_absolute_max);

    if (use_combined_bounds) {
        const uvec2 tile_count = cmds_max_tile - cmds_min_tile + uvec2(1);
        const uint count = tile_count.x * tile_count.y;

        uint offset;
        if (subgroupElect()) {
            offset = atomicAdd(constants.coarse_buffer.values[0], count) + 1;
        }
        offset = subgroupBroadcastFirst(offset);

        if (offset >= constants.coarse_buffer_len) {
            return;
        }

        for (uint y = 0; y < tile_count.y; y++) {
            for (uint x = 0; x < tile_count.x; x += gl_SubgroupSize) {
                const uint local_x = x + gl_SubgroupInvocationID;
                if (local_x < tile_count.x) {
                    const uint yy = cmds_min_tile.y + y;
                    const uint xx = cmds_min_tile.x + local_x;
                    const uint packed = ((yy & 0xff) << 24) | ((xx & 0xff) << 16) | (gl_WorkGroupID.x & 0xffff);
                    constants.coarse_buffer.values[offset + local_x] = packed;
                }
                subgroupBarrier();
            }
            offset += tile_count.x;
        }
    } else {
        for (uint i = 0; i < BITMAP_SIZE; i += gl_SubgroupSize) {
            intersected_tiles[i + gl_SubgroupInvocationID] = 0;
        }

        subgroupBarrier();

        {
            const uint min_word = cmd_min_tile.x / 32;
            const uint max_word = cmd_max_tile.x / 32;
            const uint min_bit = cmd_min_tile.x & 31;
            const uint max_bit = cmd_max_tile.x & 31;
            const uint lsb = ~((1 << min_bit) - 1);
            const uint msb = ((1 << max_bit) - 1) | 1 << max_bit;
            if (min_word == max_word) {
                for (uint y = cmd_min_tile.y; y <= cmd_max_tile.y; y++) {
                    atomicOr(intersected_tiles[y * BITMAP_STRIDE + min_word], lsb & msb);
                }
            } else {
                for (uint y = cmd_min_tile.y; y <= cmd_max_tile.y; y++) {
                    atomicOr(intersected_tiles[y * BITMAP_STRIDE + min_word], lsb);
                    for (uint i = min_word + 1; i <= (max_word - 1); i++) {
                        intersected_tiles[y * BITMAP_STRIDE + i] = 0xffffffff;
                    }
                    atomicOr(intersected_tiles[y * BITMAP_STRIDE + max_word], msb);
                }
            }
        }

        subgroupBarrier();

        uint count = 0;
        for (uint i = 0; i < BITMAP_SIZE; i += gl_SubgroupSize) {
            count += subgroupAdd(bitCount(intersected_tiles[i + gl_SubgroupInvocationID]));
        }

        if (count == 0) {
            return;
        }

        uint offset;
        if (subgroupElect()) {
            offset = atomicAdd(constants.coarse_buffer.values[0], count) + 1;
        }
        offset = subgroupBroadcastFirst(offset);

        const uint start = cmds_min_tile.y * BITMAP_STRIDE + cmds_min_tile.x / 32;
        const uint end = cmds_max_tile.y * BITMAP_STRIDE + cmds_max_tile.x / 32;

        for (uint i = start; i <= end; i += gl_SubgroupSize) {
            const uint ii = i + gl_SubgroupInvocationID;
            uint bitmap = intersected_tiles[ii];
            const uint count = bitCount(bitmap);
            uint scan = subgroupExclusiveAdd(count);

            while (bitmap != 0) {
                const uint index = findLSB(bitmap);
                bitmap ^= bitmap & -bitmap;
                const uint y = (ii * 32 + index) / MAX_TILES;
                const uint x = (ii * 32 + index) & (MAX_TILES - 1);
                const uint packed = (y << 24) | (x << 16) | (gl_WorkGroupID.x & 0xffff);
                constants.coarse_buffer.values[offset + scan] = packed;
                scan++;
            }

            offset += subgroupAdd(count);
        }
    }
}
